Краткое описание структуры модулей и классов.
— config.h: заголовочный файл, содержащий директивы define, включающие те или иные экспериментальные или не входящие в условие изначальной задачи функции.
— exceptions.h: заголовочный файл, содержащий простую иерархию исключений — класс Exception, унаследованный от std::runtime_error, от которого унаследованы классы LexicalError, SyntaxError, SemanticError и InterpretationError; интерфейс у всех классов одинаков и совпадает с интерфейсом класса std::runtime_error.
— lexeme.h: содержит класс Lexeme, хранящий в себе тип лексемы (LexemeType), её строковое представление (для идентификаторов и констант оно, фактически, хранит в себе значение лексемы; в остальных случаях оно упрощает вывод лексемы в консоль), позицию в коде (номер строки и номер символа в строке); предоставляющий методы-геттеры для типа и строкового представления и метод print, используемый для отладки и сообщения о синтаксических и семантических ошибках.
— lexical.h: содержит класс LexicalAnalyzer, получающий на вход с помощью методов parse_stream или parse_string поток или строку соответственно с кодом исходной программы и возвращающий методом get_lexemes массив лексем. В ходе лексического анализа могут быть найдены следующие ошибки: неизвесный символ в коде (например, ₽); неожиданный символ после числа (например, 123abc), пустая дробная часть числа (например, 123.), незакрытая строка или комментарий. Лексический анализатор умеет находить числа со знаком как отдельные лексемы (-123 — лексема «число -123», а не лексемы «знак -» и «число 123»), отделять унарные от бинарных операций и различать идентификаторы от служебных слов.
— values.h: содержит ирерахию классов, служащих для хранения значений. Абстрактный класс Value имеет методы для приведения хранимого значения во все доступные типы (to_integer, to_string, to_boolean и to_real); унаследованные от него классы IntegerValue, StringValue, BooleanValue, RealValue имеют конструкторы из значения соответствующего типа и из строки и предоставляют реализации этих методов. Подобная архитектура позволяет не осуществлять контроль типов на этапе интерпретации и упрощает такие действия, как ввод и вывод.
— variables.h: содержит класс VariablesTable, служащий для хранения списка объявленных переменных и их типов, что используется при семантическом анализе.
— labels.h: содержит класс LabelsTable, используемый для генерации переходов. Поскольку на этапе генерации перехода конечный адрес обычно неизвестен (например, при генерации структуры if-then-else необходимо после генерации выражения сгенерировать переход по лжи на блок else, адрес которого не известен, так как генерация блока then не завершена и его размер предугадать невозможно), нам требуется хранить информацию о переходах. В этом случае генератор регистрирует метку в классе LabelsTable, получая её номер (new_label); когда требуется сгенерировать переход, оставляется под него место в ПОЛИЗе и передаёт его позицию в класс (add_node); когда адрес становится известен, он привязывается к метке (set_value). После генерации вызывается метод propagate, в который передаётся почти готовая программа, в рамках которого инициализируются метки.
— syntax.h: содержит класс SyntaxAnalyzer, осуществляющий синтаксический анализ (например, проверки на наличие точек с запятой), семантический анализ (например, контроль типов операндов в выражениях) и генерацию ПОЛИЗа.
— operations.h: содержит enum со списком всех используемых в ПОЛИЗе инструкций и функции для вычисления арифметических инструкций.
— program.h: содержит интерпретатор ПОЛИЗа.